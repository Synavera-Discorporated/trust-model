"""
============================================================
 Synavera Project: trust-model
 Module: trust_spec/strategies.py
 Etiquette: Synavera Script Etiquette (SSE v1.2)
------------------------------------------------------------
 Purpose:
   Hypothesis strategies for generating event streams and identifiers.
 Invariants:
   Strategies are pure and deterministic for a given seed.
 Trust Boundaries:
   No external I/O; returns Hypothesis strategies only.
 Security / Safety Notes:
   N/A.
 Dependencies:
   hypothesis.
 Operational Scope:
   Used by property-based tests to create input data.
 Revision History:
   2026-01-06 COD  Added SSE header for auditability.
   2026-01-06 COD  Added invariants and trust boundary notes.
   2026-01-06 COD  Replaced lambdas with named helpers for clarity.
   2026-01-06 COD  Added narrative comments for section intent.
   2026-01-06 COD  Added fields for pressure-point telemetry and drift tests.
------------------------------------------------------------
 SSE Principles Observed:
   - Explicit Result-based API (no silent failures)
   - Narrative comments for auditability
   - No hidden state changes; all mutations are explicit
   - Modular structure with clear boundaries
============================================================
"""

from __future__ import annotations

from typing import Any, Dict, List, Optional

from hypothesis import strategies as st

ALPHABET = "abcdefghijklmnopqrstuvwxyz0123456789"
# Keep identifiers short and ASCII-only so failing examples stay readable in logs and diffs.


def _format_id(prefix: str, suffix: str) -> str:
    """Format a namespaced identifier from a prefix and suffix.

    Args:
        prefix: Namespace prefix for the identifier.
        suffix: Suffix value to append.

    Returns:
        Namespaced identifier string.

    Resources:
        None.

    Raises:
        None.
    """
    return f"{prefix}_{suffix}"


def _id(prefix: str) -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy or event payload.

    Args:
        prefix: Input value for this helper.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(_format_id, st.just(prefix), st.text(ALPHABET, min_size=1, max_size=8))


def _pair_from_list(users: List[str]) -> tuple[str, str]:
    """Build a tuple pair from a list of two S-User identifiers.

    Args:
        users: List containing exactly two identifiers.

    Returns:
        Tuple of (first, second) identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return users[0], users[1]


# Typed ID strategies keep entity roles clear without handcrafting strings in every test.
def suser_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for suser identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("suser")


def unique_susers_list(min_size: int = 2, max_size: int = 3) -> st.SearchStrategy[List[str]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        min_size: Input value for this helper.
        max_size: Input value for this helper.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.lists(suser_ids(), min_size=min_size, max_size=max_size, unique=True)


def distinct_suser_pair() -> st.SearchStrategy[tuple[str, str]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        None.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return unique_susers_list(min_size=2, max_size=2).map(_pair_from_list)


def service_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for service identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("service")


def telemetry_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for telemetry identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("telemetry")


def environment_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for environment identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("env")


def decision_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for decision identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("decision")


def delegation_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for delegation identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("delegation")


def consent_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for consent identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("consent")


def default_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for default identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("default")


def enforcement_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for enforcement identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("enforce")


def disclosure_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for disclosure identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("disclosure")


def limitation_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for limitation identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("limit")


def audit_ids() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for audit identifiers.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for identifiers.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("audit")


# Small numeric ranges keep counterexamples compact and legible.
def durations() -> st.SearchStrategy[int]:
    """Build a Hypothesis strategy for durations.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for generated values.

    Resources:
        None.

    Raises:
        None.
    """
    return st.integers(min_value=1, max_value=10)


def time_ticks() -> st.SearchStrategy[int]:
    """Build a Hypothesis strategy for time ticks.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for generated values.

    Resources:
        None.

    Raises:
        None.
    """
    return st.integers(min_value=1, max_value=5)


def contexts() -> st.SearchStrategy[str]:
    """Build a Hypothesis strategy for contexts.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for generated values.

    Resources:
        None.

    Raises:
        None.
    """
    return _id("ctx")


# Scope payloads stay minimal so tests focus on structure, not domain prose.
def scopes() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for scopes.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for generated values.

    Resources:
        None.

    Raises:
        None.
    """
    return st.fixed_dictionaries(
        {
            "purpose": st.text(ALPHABET, min_size=1, max_size=12),
            "context_id": contexts(),
            "duration": durations(),
            "effect": st.text(ALPHABET, min_size=1, max_size=12),
        }
    )


# Event constructors are the canonical payload shapes; tests flip flags to model compliance or violations.
def make_delegation_event(
    delegation_id: str,
    suser_id: str,
    grantee_id: str,
    *,
    explicit: bool = True,
    scoped: bool = True,
    revocable: bool = True,
    derived_from_use: bool = False,
    suser_can_inspect: bool = True,
    suser_can_contest: bool = True,
    suser_can_revoke: bool = True,
    scope: Optional[Dict[str, Any]] = None,
    revocation_path: Optional[str] = "revoke",
    justification: Optional[str] = None,
) -> Dict[str, Any]:
    """Build a delegation event dictionary.

    Args:
        delegation_id: Input value for this helper.
        suser_id: Input value for this helper.
        grantee_id: Input value for this helper.
        explicit: Input value for this helper.
        scoped: Input value for this helper.
        revocable: Input value for this helper.
        derived_from_use: Input value for this helper.
        suser_can_inspect: Input value for this helper.
        suser_can_contest: Input value for this helper.
        suser_can_revoke: Input value for this helper.
        scope: Input value for this helper.
        revocation_path: Input value for this helper.
        justification: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "delegation",
        "delegation_id": delegation_id,
        "suser_id": suser_id,
        "grantee_id": grantee_id,
        "explicit": explicit,
        "scoped": scoped,
        "revocable": revocable,
        "derived_from_use": derived_from_use,
        "suser_can_inspect": suser_can_inspect,
        "suser_can_contest": suser_can_contest,
        "suser_can_revoke": suser_can_revoke,
        "scope": scope or {"purpose": "p", "context_id": "ctx", "duration": 1, "effect": "e"},
        "revocation_path": revocation_path,
        "justification": justification,
    }


def make_revoke_delegation_event(
    delegation_id: str, *, delay: int = 0, delay_disclosed: Optional[bool] = None
) -> Dict[str, Any]:
    """Build a revoke delegation event dictionary.

    Args:
        delegation_id: Input value for this helper.
        delay: Input value for this helper.
        delay_disclosed: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "revoke_delegation",
        "delegation_id": delegation_id,
        "delay": delay,
        "delay_disclosed": delay_disclosed,
    }


def make_consent_event(
    consent_id: str,
    suser_id: str,
    *,
    purpose: str = "purpose",
    informed: bool = True,
    specific: bool = True,
    revocable: bool = True,
    revocation_effective: bool = True,
    bundled: bool = False,
    coerced: bool = False,
    dark_pattern: bool = False,
    assumed_by_use: bool = False,
    justification: Optional[str] = None,
) -> Dict[str, Any]:
    """Build a consent event dictionary.

    Args:
        consent_id: Input value for this helper.
        suser_id: Input value for this helper.
        purpose: Input value for this helper.
        informed: Input value for this helper.
        specific: Input value for this helper.
        revocable: Input value for this helper.
        revocation_effective: Input value for this helper.
        bundled: Input value for this helper.
        coerced: Input value for this helper.
        dark_pattern: Input value for this helper.
        assumed_by_use: Input value for this helper.
        justification: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "consent",
        "consent_id": consent_id,
        "suser_id": suser_id,
        "purpose": purpose,
        "informed": informed,
        "specific": specific,
        "revocable": revocable,
        "revocation_effective": revocation_effective,
        "bundled": bundled,
        "coerced": coerced,
        "dark_pattern": dark_pattern,
        "assumed_by_use": assumed_by_use,
        "justification": justification,
    }


def make_withdraw_consent_event(consent_id: str) -> Dict[str, Any]:
    """Build a withdraw consent event dictionary.

    Args:
        consent_id: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {"type": "withdraw_consent", "consent_id": consent_id}


def make_telemetry_event(
    telemetry_id: str,
    *,
    influences: bool = False,
    explained: bool = True,
    human_explainable: bool = True,
    prescriptive_use: bool = False,
    reports_to_service: bool = True,
    self_originating: bool = False,
    justification: Optional[str] = None,
) -> Dict[str, Any]:
    """Build a telemetry event dictionary.

    Args:
        telemetry_id: Input value for this helper.
        influences: Input value for this helper.
        explained: Input value for this helper.
        human_explainable: Input value for this helper.
        prescriptive_use: Input value for this helper.
        reports_to_service: Input value for this helper.
        self_originating: Input value for this helper.
        justification: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "telemetry",
        "telemetry_id": telemetry_id,
        "influences": influences,
        "explained": explained,
        "human_explainable": human_explainable,
        "prescriptive_use": prescriptive_use,
        "reports_to_service": reports_to_service,
        "self_originating": self_originating,
        "justification": justification,
    }


def make_service_action_event(
    decision_id: str,
    suser_id: Optional[str],
    service_id: str,
    *,
    delegation_id: Optional[str] = None,
    consent_id: Optional[str] = None,
    telemetry_refs: Optional[List[str]] = None,
    telemetry_attribution_complete: bool = True,
    telemetry_aggregate: bool = False,
    telemetry_aggregate_sources: Optional[List[str]] = None,
    self_telemetry_contained: bool = True,
    disclosed: bool = True,
    justified: bool = True,
    basis_in_delegation: bool = True,
    report_to_suser: bool = True,
    explanation: str = "explanation",
    explanation_legible: bool = True,
    contest_path: Optional[str] = "contest",
    revocation_path: Optional[str] = "revoke",
    authority_chain_complete: bool = True,
    ordering_inverted: bool = False,
    reporting_constraints: Optional[bool] = None,
    reporting_constraints_disclosed: bool = True,
    diagnostic_ready: bool = True,
    automated: bool = False,
    within_scope: bool = True,
    behavior_drift: bool = False,
    mutation_authority: bool = False,
    admin_override: bool = False,
    lower_layer_authority_accumulation: bool = False,
    higher_layer_can_intervene: bool = True,
    inferred_intent: bool = False,
    context_id: str = "ctx",
    affected_susers: Optional[List[str]] = None,
    justification: Optional[str] = None,
    receipt_delivered: Optional[bool] = None,
    explanation_delivered: Optional[bool] = None,
    redacted_fields: Optional[List[str]] = None,
    explanation_contextual: Optional[bool] = None,
    authority_chain_override: Optional[List[Any]] = None,
) -> Dict[str, Any]:
    """Build a service action event dictionary.

    Args:
        decision_id: Input value for this helper.
        suser_id: Input value for this helper.
        service_id: Input value for this helper.
        delegation_id: Input value for this helper.
        consent_id: Input value for this helper.
        telemetry_refs: Input value for this helper.
        telemetry_attribution_complete: Input value for this helper.
        telemetry_aggregate: Input value for this helper.
        telemetry_aggregate_sources: Input value for this helper.
        self_telemetry_contained: Input value for this helper.
        disclosed: Input value for this helper.
        justified: Input value for this helper.
        basis_in_delegation: Input value for this helper.
        report_to_suser: Input value for this helper.
        explanation: Input value for this helper.
        explanation_legible: Input value for this helper.
        contest_path: Input value for this helper.
        revocation_path: Input value for this helper.
        authority_chain_complete: Input value for this helper.
        ordering_inverted: Input value for this helper.
        reporting_constraints: Input value for this helper.
        reporting_constraints_disclosed: Input value for this helper.
        diagnostic_ready: Input value for this helper.
        automated: Input value for this helper.
        within_scope: Input value for this helper.
        behavior_drift: Input value for this helper.
        mutation_authority: Input value for this helper.
        admin_override: Input value for this helper.
        lower_layer_authority_accumulation: Input value for this helper.
        higher_layer_can_intervene: Input value for this helper.
        inferred_intent: Input value for this helper.
        context_id: Input value for this helper.
        affected_susers: Input value for this helper.
        justification: Input value for this helper.
        receipt_delivered: Input value for this helper.
        explanation_delivered: Input value for this helper.
        redacted_fields: Input value for this helper.
        explanation_contextual: Input value for this helper.
        authority_chain_override: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "service_action",
        "decision_id": decision_id,
        "suser_id": suser_id,
        "service_id": service_id,
        "delegation_id": delegation_id,
        "consent_id": consent_id,
        "telemetry_refs": telemetry_refs or [],
        "telemetry_attribution_complete": telemetry_attribution_complete,
        "telemetry_aggregate": telemetry_aggregate,
        "telemetry_aggregate_sources": telemetry_aggregate_sources or [],
        "self_telemetry_contained": self_telemetry_contained,
        "disclosed": disclosed,
        "justified": justified,
        "basis_in_delegation": basis_in_delegation,
        "report_to_suser": report_to_suser,
        "explanation": explanation,
        "explanation_legible": explanation_legible,
        "contest_path": contest_path,
        "revocation_path": revocation_path,
        "authority_chain_complete": authority_chain_complete,
        "ordering_inverted": ordering_inverted,
        "reporting_constraints": reporting_constraints,
        "reporting_constraints_disclosed": reporting_constraints_disclosed,
        "diagnostic_ready": diagnostic_ready,
        "automated": automated,
        "within_scope": within_scope,
        "behavior_drift": behavior_drift,
        "mutation_authority": mutation_authority,
        "admin_override": admin_override,
        "lower_layer_authority_accumulation": lower_layer_authority_accumulation,
        "higher_layer_can_intervene": higher_layer_can_intervene,
        "inferred_intent": inferred_intent,
        "context_id": context_id,
        "affected_susers": affected_susers or [],
        "justification": justification,
        "receipt_delivered": receipt_delivered,
        "explanation_delivered": explanation_delivered,
        "redacted_fields": redacted_fields,
        "explanation_contextual": explanation_contextual,
        "authority_chain_override": authority_chain_override,
    }


def make_shared_action_event(
    environment_id: str,
    actor_suser_id: str,
    *,
    affected_susers: Optional[List[str]] = None,
    consent_basis: str = "mutual",
    consent_legible: bool = True,
    boundary_constraints_met: bool = True,
    internal_accountable: bool = True,
    cross_context: bool = False,
    renewed_consent: bool = True,
    influence_disclosed: bool = True,
    scope_constrained: bool = True,
    diagnostic_ready: bool = True,
) -> Dict[str, Any]:
    """Build a shared action event dictionary.

    Args:
        environment_id: Input value for this helper.
        actor_suser_id: Input value for this helper.
        affected_susers: Input value for this helper.
        consent_basis: Input value for this helper.
        consent_legible: Input value for this helper.
        boundary_constraints_met: Input value for this helper.
        internal_accountable: Input value for this helper.
        cross_context: Input value for this helper.
        renewed_consent: Input value for this helper.
        influence_disclosed: Input value for this helper.
        scope_constrained: Input value for this helper.
        diagnostic_ready: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "shared_action",
        "environment_id": environment_id,
        "actor_suser_id": actor_suser_id,
        "affected_susers": affected_susers or [actor_suser_id],
        "consent_basis": consent_basis,
        "consent_legible": consent_legible,
        "boundary_constraints_met": boundary_constraints_met,
        "internal_accountable": internal_accountable,
        "cross_context": cross_context,
        "renewed_consent": renewed_consent,
        "influence_disclosed": influence_disclosed,
        "scope_constrained": scope_constrained,
        "diagnostic_ready": diagnostic_ready,
    }


def make_boundary_declaration_event(
    environment_id: str,
    *,
    explicit: bool = True,
    scope: Optional[Dict[str, Any]] = None,
    constraints: Optional[Dict[str, Any]] = None,
) -> Dict[str, Any]:
    """Build a boundary declaration event dictionary.

    Args:
        environment_id: Input value for this helper.
        explicit: Input value for this helper.
        scope: Input value for this helper.
        constraints: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "boundary_declaration",
        "environment_id": environment_id,
        "explicit": explicit,
        "scope": scope or {"context_id": "ctx", "purpose": "p"},
        "constraints": constraints or {"no_cross": True},
    }


def make_entry_condition_event(environment_id: str, *, conditions_defined: bool = True) -> Dict[str, Any]:
    """Build a entry condition event dictionary.

    Args:
        environment_id: Input value for this helper.
        conditions_defined: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "entry_condition",
        "environment_id": environment_id,
        "conditions_defined": conditions_defined,
    }


def make_entry_request_event(
    environment_id: str,
    *,
    entry_conditions_met: bool = True,
    entry_conditions_declared: bool = True,
) -> Dict[str, Any]:
    """Build a entry request event dictionary.

    Args:
        environment_id: Input value for this helper.
        entry_conditions_met: Input value for this helper.
        entry_conditions_declared: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "entry_request",
        "environment_id": environment_id,
        "entry_conditions_met": entry_conditions_met,
        "entry_conditions_declared": entry_conditions_declared,
    }


def make_boundary_rule_event(environment_id: str, *, interface_rules_present: bool = True) -> Dict[str, Any]:
    """Build a boundary rule event dictionary.

    Args:
        environment_id: Input value for this helper.
        interface_rules_present: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "boundary_rule",
        "environment_id": environment_id,
        "interface_rules_present": interface_rules_present,
    }


def make_revocation_policy_event(
    environment_id: str,
    *,
    monitoring: bool = True,
    revocation_legible: bool = True,
    revocation_contestable: bool = True,
    revocation_delay: bool = False,
    revocation_delay_disclosed: bool = True,
) -> Dict[str, Any]:
    """Build a revocation policy event dictionary.

    Args:
        environment_id: Input value for this helper.
        monitoring: Input value for this helper.
        revocation_legible: Input value for this helper.
        revocation_contestable: Input value for this helper.
        revocation_delay: Input value for this helper.
        revocation_delay_disclosed: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "revocation_policy",
        "environment_id": environment_id,
        "monitoring": monitoring,
        "revocation_legible": revocation_legible,
        "revocation_contestable": revocation_contestable,
        "revocation_delay": revocation_delay,
        "revocation_delay_disclosed": revocation_delay_disclosed,
    }


def make_default_event(
    default_id: str,
    *,
    exploits_bias: bool = False,
    expands_scope: bool = False,
    privileges_platform: bool = False,
    justifiable: bool = True,
    reversible: bool = True,
    duration: Optional[int] = None,
    active: bool = True,
) -> Dict[str, Any]:
    """Build a default event dictionary.

    Args:
        default_id: Input value for this helper.
        exploits_bias: Input value for this helper.
        expands_scope: Input value for this helper.
        privileges_platform: Input value for this helper.
        justifiable: Input value for this helper.
        reversible: Input value for this helper.
        duration: Input value for this helper.
        active: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "default_setting",
        "default_id": default_id,
        "exploits_bias": exploits_bias,
        "expands_scope": expands_scope,
        "privileges_platform": privileges_platform,
        "justifiable": justifiable,
        "reversible": reversible,
        "duration": duration,
        "active": active,
    }


def make_time_advance_event(ticks: int = 1) -> Dict[str, Any]:
    """Build a time advance event dictionary.

    Args:
        ticks: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {"type": "time_advance", "ticks": ticks}


def make_federated_governance_event(
    environment_id: str,
    *,
    entry_exit_defined: bool = True,
    non_interference: bool = True,
    auditability: bool = True,
    contestable: bool = True,
) -> Dict[str, Any]:
    """Build a federated governance event dictionary.

    Args:
        environment_id: Input value for this helper.
        entry_exit_defined: Input value for this helper.
        non_interference: Input value for this helper.
        auditability: Input value for this helper.
        contestable: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "federated_governance",
        "environment_id": environment_id,
        "entry_exit_defined": entry_exit_defined,
        "non_interference": non_interference,
        "auditability": auditability,
        "contestable": contestable,
    }


def make_boundary_failure_modes_event(
    environment_id: str,
    *,
    implicit_consent: bool = False,
    opaque_enforcement: bool = False,
    hidden_influence: bool = False,
    irrevocable_participation: bool = False,
) -> Dict[str, Any]:
    """Build a boundary failure modes event dictionary.

    Args:
        environment_id: Input value for this helper.
        implicit_consent: Input value for this helper.
        opaque_enforcement: Input value for this helper.
        hidden_influence: Input value for this helper.
        irrevocable_participation: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "boundary_failure_modes",
        "environment_id": environment_id,
        "implicit_consent": implicit_consent,
        "opaque_enforcement": opaque_enforcement,
        "hidden_influence": hidden_influence,
        "irrevocable_participation": irrevocable_participation,
    }


def make_respect_principles_event(
    environment_id: str,
    *,
    boundary_integrity: bool = True,
    non_coercion: bool = True,
    mutual_legibility: bool = True,
    contextual_consent: bool = True,
    contestability: bool = True,
) -> Dict[str, Any]:
    """Build a respect principles event dictionary.

    Args:
        environment_id: Input value for this helper.
        boundary_integrity: Input value for this helper.
        non_coercion: Input value for this helper.
        mutual_legibility: Input value for this helper.
        contextual_consent: Input value for this helper.
        contestability: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "respect_principles",
        "environment_id": environment_id,
        "boundary_integrity": boundary_integrity,
        "non_coercion": non_coercion,
        "mutual_legibility": mutual_legibility,
        "contextual_consent": contextual_consent,
        "contestability": contestability,
    }


def make_participation_declaration_event(
    environment_id: str,
    *,
    scope_declared: bool = True,
    influence_declared: bool = True,
    boundaries_declared: bool = True,
    enforcement_legible: bool = True,
    enforcement_proportionate: bool = True,
    enforcement_contestable: bool = True,
) -> Dict[str, Any]:
    """Build a participation declaration event dictionary.

    Args:
        environment_id: Input value for this helper.
        scope_declared: Input value for this helper.
        influence_declared: Input value for this helper.
        boundaries_declared: Input value for this helper.
        enforcement_legible: Input value for this helper.
        enforcement_proportionate: Input value for this helper.
        enforcement_contestable: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "participation_declaration",
        "environment_id": environment_id,
        "scope_declared": scope_declared,
        "influence_declared": influence_declared,
        "boundaries_declared": boundaries_declared,
        "enforcement_legible": enforcement_legible,
        "enforcement_proportionate": enforcement_proportionate,
        "enforcement_contestable": enforcement_contestable,
    }


def make_trust_audit_event(audit_id: str, *, minimum_met: bool = True) -> Dict[str, Any]:
    """Build a trust audit event dictionary.

    Args:
        audit_id: Input value for this helper.
        minimum_met: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {"type": "trust_audit", "audit_id": audit_id, "minimum_met": minimum_met}


def make_respect_audit_event(audit_id: str, *, minimum_met: bool = True) -> Dict[str, Any]:
    """Build a respect audit event dictionary.

    Args:
        audit_id: Input value for this helper.
        minimum_met: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {"type": "respect_audit", "audit_id": audit_id, "minimum_met": minimum_met}


def make_enforcement_event(
    enforcement_id: str,
    enforcer_id: str,
    *,
    proportionate: bool = True,
    transparent: bool = True,
    contestable: bool = True,
    reversible: bool = True,
    punitive: bool = False,
    attributable: bool = True,
    contest_path: Optional[str] = "contest",
) -> Dict[str, Any]:
    """Build a enforcement event dictionary.

    Args:
        enforcement_id: Input value for this helper.
        enforcer_id: Input value for this helper.
        proportionate: Input value for this helper.
        transparent: Input value for this helper.
        contestable: Input value for this helper.
        reversible: Input value for this helper.
        punitive: Input value for this helper.
        attributable: Input value for this helper.
        contest_path: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "enforcement",
        "enforcement_id": enforcement_id,
        "enforcer_id": enforcer_id,
        "proportionate": proportionate,
        "transparent": transparent,
        "contestable": contestable,
        "reversible": reversible,
        "punitive": punitive,
        "attributable": attributable,
        "contest_path": contest_path,
    }


def make_disclosure_event(disclosure_id: str, *, user_actionable: bool = True) -> Dict[str, Any]:
    """Build a disclosure event dictionary.

    Args:
        disclosure_id: Input value for this helper.
        user_actionable: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {"type": "disclosure", "disclosure_id": disclosure_id, "user_actionable": user_actionable}


def make_limitation_disclosure_event(
    limitation_id: str, *, limits_disclosed: bool = True
) -> Dict[str, Any]:
    """Build a limitation disclosure event dictionary.

    Args:
        limitation_id: Input value for this helper.
        limits_disclosed: Input value for this helper.

    Returns:
        Event dictionary payload.

    Resources:
        None.

    Raises:
        None.
    """
    return {
        "type": "limitation_disclosure",
        "limitation_id": limitation_id,
        "limits_disclosed": limits_disclosed,
    }


# Event strategy groups provide reusable generators for targeted tests.
def delegation_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for delegation events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.booleans(),
        scoped=st.booleans(),
        revocable=st.booleans(),
        derived_from_use=st.booleans(),
        suser_can_inspect=st.booleans(),
        suser_can_contest=st.booleans(),
        suser_can_revoke=st.booleans(),
        scope=scopes(),
        revocation_path=st.text(ALPHABET, min_size=1, max_size=8),
        justification=st.one_of(st.none(), st.just("scale"), st.just("optimization")),
    )


def consent_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for consent events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.booleans(),
        specific=st.booleans(),
        revocable=st.booleans(),
        revocation_effective=st.booleans(),
        bundled=st.booleans(),
        coerced=st.booleans(),
        dark_pattern=st.booleans(),
        assumed_by_use=st.booleans(),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )


def telemetry_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for telemetry events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.booleans(),
        explained=st.booleans(),
        human_explainable=st.booleans(),
        prescriptive_use=st.booleans(),
        reports_to_service=st.booleans(),
        justification=st.one_of(st.none(), st.just("scale")),
    )


def service_action_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for service action events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=st.one_of(suser_ids(), st.none()),
        service_id=service_ids(),
        delegation_id=st.one_of(delegation_ids(), st.none()),
        consent_id=st.one_of(consent_ids(), st.none()),
        telemetry_refs=st.lists(telemetry_ids(), min_size=0, max_size=3),
        disclosed=st.booleans(),
        justified=st.booleans(),
        basis_in_delegation=st.booleans(),
        report_to_suser=st.booleans(),
        explanation=st.text(ALPHABET, min_size=0, max_size=12),
        explanation_legible=st.booleans(),
        contest_path=st.one_of(st.text(ALPHABET, min_size=1, max_size=6), st.none()),
        revocation_path=st.one_of(st.text(ALPHABET, min_size=1, max_size=6), st.none()),
        authority_chain_complete=st.booleans(),
        ordering_inverted=st.booleans(),
        reporting_constraints=st.one_of(st.none(), st.booleans()),
        reporting_constraints_disclosed=st.booleans(),
        diagnostic_ready=st.booleans(),
        automated=st.booleans(),
        within_scope=st.booleans(),
        admin_override=st.booleans(),
        lower_layer_authority_accumulation=st.booleans(),
        higher_layer_can_intervene=st.booleans(),
        inferred_intent=st.booleans(),
        context_id=contexts(),
        affected_susers=st.lists(suser_ids(), min_size=0, max_size=3),
        justification=st.one_of(st.none(), st.just("scale")),
        receipt_delivered=st.one_of(st.none(), st.booleans()),
        explanation_delivered=st.one_of(st.none(), st.booleans()),
        redacted_fields=st.one_of(
            st.none(),
            st.lists(
                st.sampled_from(
                    ["authority_chain", "explanation", "explanation_legible", "telemetry_refs"]
                ),
                min_size=1,
                max_size=2,
                unique=True,
            ),
        ),
        explanation_contextual=st.one_of(st.none(), st.booleans()),
        authority_chain_override=st.one_of(
            st.none(),
            st.lists(
                st.one_of(suser_ids(), service_ids(), st.text(ALPHABET, min_size=1, max_size=4)),
                min_size=1,
                max_size=3,
            ),
        ),
    )


def shared_action_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for shared action events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_shared_action_event,
        environment_id=environment_ids(),
        actor_suser_id=suser_ids(),
        affected_susers=st.lists(suser_ids(), min_size=1, max_size=3),
        consent_basis=st.sampled_from(["mutual", "federated", "none", "unilateral"]),
        consent_legible=st.booleans(),
        boundary_constraints_met=st.booleans(),
        internal_accountable=st.booleans(),
        cross_context=st.booleans(),
        renewed_consent=st.booleans(),
        influence_disclosed=st.booleans(),
        scope_constrained=st.booleans(),
        diagnostic_ready=st.booleans(),
    )


def boundary_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for boundary events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.one_of(
        st.builds(make_boundary_declaration_event, environment_id=environment_ids(), explicit=st.booleans()),
        st.builds(make_entry_condition_event, environment_id=environment_ids(), conditions_defined=st.booleans()),
        st.builds(make_entry_request_event, environment_id=environment_ids(), entry_conditions_met=st.booleans(), entry_conditions_declared=st.booleans()),
        st.builds(make_boundary_rule_event, environment_id=environment_ids(), interface_rules_present=st.booleans()),
        st.builds(make_revocation_policy_event, environment_id=environment_ids(), monitoring=st.booleans(), revocation_legible=st.booleans(), revocation_contestable=st.booleans(), revocation_delay=st.booleans(), revocation_delay_disclosed=st.booleans()),
        st.builds(
            make_default_event,
            default_id=default_ids(),
            exploits_bias=st.booleans(),
            expands_scope=st.booleans(),
            privileges_platform=st.booleans(),
            justifiable=st.booleans(),
            reversible=st.booleans(),
            duration=st.one_of(st.none(), durations()),
            active=st.booleans(),
        ),
        st.builds(make_federated_governance_event, environment_id=environment_ids(), entry_exit_defined=st.booleans(), non_interference=st.booleans(), auditability=st.booleans(), contestable=st.booleans()),
        st.builds(make_boundary_failure_modes_event, environment_id=environment_ids(), implicit_consent=st.booleans(), opaque_enforcement=st.booleans(), hidden_influence=st.booleans(), irrevocable_participation=st.booleans()),
        st.builds(make_respect_principles_event, environment_id=environment_ids(), boundary_integrity=st.booleans(), non_coercion=st.booleans(), mutual_legibility=st.booleans(), contextual_consent=st.booleans(), contestability=st.booleans()),
        st.builds(make_participation_declaration_event, environment_id=environment_ids(), scope_declared=st.booleans(), influence_declared=st.booleans(), boundaries_declared=st.booleans(), enforcement_legible=st.booleans(), enforcement_proportionate=st.booleans(), enforcement_contestable=st.booleans()),
    )


def enforcement_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for enforcement events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_enforcement_event,
        enforcement_id=enforcement_ids(),
        enforcer_id=service_ids(),
        proportionate=st.booleans(),
        transparent=st.booleans(),
        contestable=st.booleans(),
        reversible=st.booleans(),
        punitive=st.booleans(),
        attributable=st.booleans(),
        contest_path=st.one_of(st.text(ALPHABET, min_size=1, max_size=6), st.none()),
    )


def audit_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for audit events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.one_of(
        st.builds(make_trust_audit_event, audit_id=audit_ids(), minimum_met=st.booleans()),
        st.builds(make_respect_audit_event, audit_id=audit_ids(), minimum_met=st.booleans()),
    )


def disclosure_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for disclosure events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.one_of(
        st.builds(make_disclosure_event, disclosure_id=disclosure_ids(), user_actionable=st.booleans()),
        st.builds(
            make_limitation_disclosure_event,
            limitation_id=limitation_ids(),
            limits_disclosed=st.booleans(),
        ),
    )


def time_advance_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for time advance events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(make_time_advance_event, ticks=time_ticks())


# Mixed-event streams surface cross-rule interactions that unit-style tests miss.
def events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a strategy for event streams.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries or sequences.

    Resources:
        None.

    Raises:
        None.
    """
    return st.one_of(
        delegation_events(),
        consent_events(),
        telemetry_events(),
        service_action_events(),
        shared_action_events(),
        boundary_events(),
        enforcement_events(),
        audit_events(),
        disclosure_events(),
        time_advance_events(),
    )


def event_sequences(
    min_size: int = 1, max_size: int = 10
) -> st.SearchStrategy[List[Dict[str, Any]]]:
    """Build a strategy for event streams.

    Args:
        min_size: Input value for this helper.
        max_size: Input value for this helper.

    Returns:
        Hypothesis SearchStrategy for event dictionaries or sequences.

    Resources:
        None.

    Raises:
        None.
    """
    return st.lists(events(), min_size=min_size, max_size=max_size)


# Hostile/adversarial strategy layer: break one rule at a time so failures stay explainable.
# Baselines are mostly valid, then we perturb a single field to expose violations.

def _mostly_valid_delegation_event() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        None.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(True),
        scoped=st.just(True),
        revocable=st.just(True),
        derived_from_use=st.just(False),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(True),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.one_of(st.none(), st.just("scale")),
    )


def hostile_delegation_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile delegation events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = _mostly_valid_delegation_event()
    bad_explicit = st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(False),
        scoped=st.just(True),
        revocable=st.just(True),
        derived_from_use=st.just(False),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(True),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.one_of(st.none(), st.just("scale")),
    )
    bad_scoped = st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(True),
        scoped=st.just(False),
        revocable=st.just(True),
        derived_from_use=st.just(False),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(True),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.one_of(st.none(), st.just("scale")),
    )
    bad_revocable = st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(True),
        scoped=st.just(True),
        revocable=st.just(False),
        derived_from_use=st.just(False),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(True),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.just("scale"),
    )
    bad_derived = st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(True),
        scoped=st.just(True),
        revocable=st.just(True),
        derived_from_use=st.just(True),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(True),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_revoke_right = st.builds(
        make_delegation_event,
        delegation_id=delegation_ids(),
        suser_id=suser_ids(),
        grantee_id=service_ids(),
        explicit=st.just(True),
        scoped=st.just(True),
        revocable=st.just(True),
        derived_from_use=st.just(False),
        suser_can_inspect=st.just(True),
        suser_can_contest=st.just(True),
        suser_can_revoke=st.just(False),
        scope=scopes(),
        revocation_path=st.just("revoke"),
        justification=st.one_of(st.none(), st.just("scale")),
    )
    return st.one_of(
        bad_explicit,
        bad_scoped,
        bad_revocable,
        bad_derived,
        bad_revoke_right,
        base,
        base,
    )


def _mostly_valid_consent_event() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        None.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("compliance")),
    )


def hostile_consent_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile consent events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = _mostly_valid_consent_event()
    bad_informed = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(False),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_specific = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(False),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_revocation = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(False),
        revocation_effective=st.just(False),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_bundled = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(True),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_coerced = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(True),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_dark = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(True),
        assumed_by_use=st.just(False),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    bad_assumed = st.builds(
        make_consent_event,
        consent_id=consent_ids(),
        suser_id=suser_ids(),
        purpose=st.text(ALPHABET, min_size=1, max_size=8),
        informed=st.just(True),
        specific=st.just(True),
        revocable=st.just(True),
        revocation_effective=st.just(True),
        bundled=st.just(False),
        coerced=st.just(False),
        dark_pattern=st.just(False),
        assumed_by_use=st.just(True),
        justification=st.one_of(st.none(), st.just("market_norm")),
    )
    return st.one_of(
        bad_informed,
        bad_specific,
        bad_revocation,
        bad_bundled,
        bad_coerced,
        bad_dark,
        bad_assumed,
        base,
        base,
    )


def _mostly_valid_telemetry_event() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        None.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(False),
        explained=st.just(True),
        human_explainable=st.just(True),
        prescriptive_use=st.just(False),
        reports_to_service=st.just(True),
        justification=st.one_of(st.none(), st.just("scale")),
    )


def hostile_telemetry_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile telemetry events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = _mostly_valid_telemetry_event()
    bad_prescriptive = st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(False),
        explained=st.just(True),
        human_explainable=st.just(True),
        prescriptive_use=st.just(True),
        reports_to_service=st.just(True),
        justification=st.just("scale"),
    )
    bad_opaque = st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(True),
        explained=st.just(False),
        human_explainable=st.just(True),
        prescriptive_use=st.just(False),
        reports_to_service=st.just(True),
        justification=st.just("scale"),
    )
    bad_inexplicable = st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(True),
        explained=st.just(True),
        human_explainable=st.just(False),
        prescriptive_use=st.just(False),
        reports_to_service=st.just(True),
        justification=st.just("scale"),
    )
    bad_reporting = st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(False),
        explained=st.just(True),
        human_explainable=st.just(True),
        prescriptive_use=st.just(False),
        reports_to_service=st.just(False),
        justification=st.one_of(st.none(), st.just("scale")),
    )
    incremental = st.builds(
        make_telemetry_event,
        telemetry_id=telemetry_ids(),
        influences=st.just(True),
        explained=st.just(True),
        human_explainable=st.just(True),
        prescriptive_use=st.just(False),
        reports_to_service=st.just(True),
        justification=st.one_of(st.none(), st.just("scale")),
    )
    return st.one_of(
        bad_prescriptive,
        bad_opaque,
        bad_inexplicable,
        bad_reporting,
        incremental,
        base,
        base,
    )


def _mostly_valid_service_action_event() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        None.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        consent_id=st.one_of(consent_ids(), st.none()),
        telemetry_refs=st.lists(telemetry_ids(), min_size=0, max_size=3),
        disclosed=st.just(True),
        justified=st.just(True),
        basis_in_delegation=st.just(True),
        report_to_suser=st.just(True),
        explanation=st.text(ALPHABET, min_size=1, max_size=12),
        explanation_legible=st.just(True),
        contest_path=st.just("contest"),
        revocation_path=st.just("revoke"),
        authority_chain_complete=st.just(True),
        ordering_inverted=st.just(False),
        reporting_constraints=st.one_of(st.none(), st.just(False)),
        reporting_constraints_disclosed=st.just(True),
        diagnostic_ready=st.just(True),
        automated=st.just(False),
        within_scope=st.just(True),
        admin_override=st.just(False),
        lower_layer_authority_accumulation=st.just(False),
        higher_layer_can_intervene=st.just(True),
        inferred_intent=st.just(False),
        context_id=contexts(),
        affected_susers=st.lists(suser_ids(), min_size=0, max_size=3),
        justification=st.one_of(st.none(), st.just("scale")),
        receipt_delivered=st.just(True),
        explanation_delivered=st.just(True),
        redacted_fields=st.none(),
        explanation_contextual=st.just(True),
        authority_chain_override=st.none(),
    )


def hostile_service_action_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile service action events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = _mostly_valid_service_action_event()
    no_report = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        report_to_suser=st.just(False),
        explanation=st.text(ALPHABET, min_size=1, max_size=12),
        explanation_legible=st.just(True),
        contest_path=st.just("contest"),
        revocation_path=st.just("revoke"),
    )
    illegible = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        report_to_suser=st.just(True),
        explanation=st.text(ALPHABET, min_size=1, max_size=12),
        explanation_legible=st.just(False),
    )
    no_contest = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        contest_path=st.none(),
    )
    no_revoke = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        revocation_path=st.none(),
    )
    broken_chain = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        authority_chain_complete=st.just(False),
    )
    withheld_receipt = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        report_to_suser=st.just(True),
        receipt_delivered=st.just(False),
    )
    redacted_explanation = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        report_to_suser=st.just(True),
        explanation=st.text(ALPHABET, min_size=1, max_size=12),
        explanation_legible=st.just(True),
        redacted_fields=st.just(["explanation", "explanation_legible"]),
    )
    generic_explanation = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        report_to_suser=st.just(True),
        explanation=st.just("ok"),
        explanation_legible=st.just(True),
        explanation_contextual=st.just(False),
    )
    obscured_chain = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        authority_chain_override=st.lists(service_ids(), min_size=2, max_size=3),
        report_to_suser=st.just(True),
    )
    inverted = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        ordering_inverted=st.just(True),
    )
    scope_mismatch = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        automated=st.just(True),
        within_scope=st.just(False),
    )
    drift = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        lower_layer_authority_accumulation=st.just(True),
    )
    no_intervene = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        higher_layer_can_intervene=st.just(False),
    )
    opaque = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        diagnostic_ready=st.just(False),
    )
    inferred = st.builds(
        make_service_action_event,
        decision_id=decision_ids(),
        suser_id=suser_ids(),
        service_id=service_ids(),
        delegation_id=delegation_ids(),
        inferred_intent=st.just(True),
        justification=st.just("scale"),
    )
    return st.one_of(
        no_report,
        illegible,
        no_contest,
        no_revoke,
        broken_chain,
        withheld_receipt,
        redacted_explanation,
        generic_explanation,
        obscured_chain,
        inverted,
        scope_mismatch,
        drift,
        no_intervene,
        opaque,
        inferred,
        base,
        base,
    )


def _shared_action_from_pair(environment_id: str, pair: tuple[str, str], **kwargs: Any) -> Dict[str, Any]:
    """Build a Hypothesis strategy or event payload.

    Args:
        environment_id: Input value for this helper.
        pair: Input value for this helper.
        kwargs: Input value for this helper.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    actor, other = pair
    return make_shared_action_event(
        environment_id,
        actor,
        affected_susers=[actor, other],
        **kwargs,
    )


def hostile_shared_action_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile shared action events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    pair = distinct_suser_pair()
    base = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("mutual"),
        consent_legible=st.just(True),
        boundary_constraints_met=st.just(True),
        internal_accountable=st.just(True),
        cross_context=st.just(False),
        renewed_consent=st.just(True),
        influence_disclosed=st.just(True),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    no_consent = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("none"),
        consent_legible=st.just(False),
        boundary_constraints_met=st.just(True),
        internal_accountable=st.just(True),
        influence_disclosed=st.just(True),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    unilateral = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("unilateral"),
        consent_legible=st.just(True),
        boundary_constraints_met=st.just(True),
        internal_accountable=st.just(True),
        influence_disclosed=st.just(True),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    hidden_influence = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("mutual"),
        consent_legible=st.just(True),
        boundary_constraints_met=st.just(True),
        internal_accountable=st.just(True),
        influence_disclosed=st.just(False),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    boundary_fail = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("mutual"),
        consent_legible=st.just(True),
        boundary_constraints_met=st.just(False),
        internal_accountable=st.just(False),
        influence_disclosed=st.just(True),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    cross_context = st.builds(
        _shared_action_from_pair,
        environment_id=environment_ids(),
        pair=pair,
        consent_basis=st.just("mutual"),
        consent_legible=st.just(True),
        boundary_constraints_met=st.just(True),
        internal_accountable=st.just(True),
        cross_context=st.just(True),
        renewed_consent=st.just(False),
        influence_disclosed=st.just(True),
        scope_constrained=st.just(True),
        diagnostic_ready=st.just(True),
    )
    return st.one_of(
        no_consent,
        unilateral,
        hidden_influence,
        boundary_fail,
        cross_context,
        base,
        base,
    )


def hostile_default_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile default events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = st.builds(
        make_default_event,
        default_id=default_ids(),
        exploits_bias=st.just(False),
        expands_scope=st.just(False),
        privileges_platform=st.just(False),
        justifiable=st.just(True),
        reversible=st.just(True),
    )
    exploits = st.builds(
        make_default_event,
        default_id=default_ids(),
        exploits_bias=st.just(True),
        expands_scope=st.just(False),
        privileges_platform=st.just(False),
        justifiable=st.just(False),
        reversible=st.just(True),
    )
    expands = st.builds(
        make_default_event,
        default_id=default_ids(),
        exploits_bias=st.just(False),
        expands_scope=st.just(True),
        privileges_platform=st.just(False),
        justifiable=st.just(False),
        reversible=st.just(True),
    )
    privileges = st.builds(
        make_default_event,
        default_id=default_ids(),
        exploits_bias=st.just(False),
        expands_scope=st.just(False),
        privileges_platform=st.just(True),
        justifiable=st.just(False),
        reversible=st.just(True),
    )
    irreversible = st.builds(
        make_default_event,
        default_id=default_ids(),
        exploits_bias=st.just(False),
        expands_scope=st.just(False),
        privileges_platform=st.just(False),
        justifiable=st.just(True),
        reversible=st.just(False),
    )
    return st.one_of(exploits, expands, privileges, irreversible, base, base)


def hostile_enforcement_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile enforcement events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    base = st.builds(
        make_enforcement_event,
        enforcement_id=enforcement_ids(),
        enforcer_id=service_ids(),
        proportionate=st.just(True),
        transparent=st.just(True),
        contestable=st.just(True),
        reversible=st.just(True),
        punitive=st.just(False),
        attributable=st.just(True),
        contest_path=st.just("contest"),
    )
    no_attr = st.builds(
        make_enforcement_event,
        enforcement_id=enforcement_ids(),
        enforcer_id=service_ids(),
        proportionate=st.just(True),
        transparent=st.just(True),
        contestable=st.just(True),
        reversible=st.just(True),
        punitive=st.just(False),
        attributable=st.just(False),
        contest_path=st.just("contest"),
    )
    heavy = st.builds(
        make_enforcement_event,
        enforcement_id=enforcement_ids(),
        enforcer_id=service_ids(),
        proportionate=st.just(False),
        transparent=st.just(False),
        contestable=st.just(False),
        reversible=st.just(False),
        punitive=st.just(True),
        attributable=st.just(True),
        contest_path=st.just("contest"),
    )
    return st.one_of(no_attr, heavy, base, base)


def hostile_boundary_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile boundary events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    bad_boundary = st.builds(
        make_boundary_declaration_event,
        environment_id=environment_ids(),
        explicit=st.just(False),
    )
    bad_entry = st.builds(
        make_entry_condition_event,
        environment_id=environment_ids(),
        conditions_defined=st.just(False),
    )
    bad_rule = st.builds(
        make_boundary_rule_event,
        environment_id=environment_ids(),
        interface_rules_present=st.just(False),
    )
    bad_revocation = st.builds(
        make_revocation_policy_event,
        environment_id=environment_ids(),
        monitoring=st.just(False),
        revocation_legible=st.just(False),
        revocation_contestable=st.just(False),
        revocation_delay=st.just(True),
        revocation_delay_disclosed=st.just(False),
    )
    bad_failure = st.builds(
        make_boundary_failure_modes_event,
        environment_id=environment_ids(),
        hidden_influence=st.just(True),
    )
    return st.one_of(bad_boundary, bad_entry, bad_rule, bad_revocation, bad_failure, boundary_events())


def hostile_time_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile time events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.builds(make_time_advance_event, ticks=st.integers(min_value=1, max_value=8))


def hostile_events() -> st.SearchStrategy[Dict[str, Any]]:
    """Build a Hypothesis strategy for hostile events.

    Args:
        None.

    Returns:
        Hypothesis SearchStrategy for event dictionaries.

    Resources:
        None.

    Raises:
        None.
    """
    return st.one_of(
        hostile_delegation_events(),
        hostile_consent_events(),
        hostile_telemetry_events(),
        hostile_service_action_events(),
        hostile_shared_action_events(),
        hostile_boundary_events(),
        hostile_default_events(),
        hostile_enforcement_events(),
        disclosure_events(),
        audit_events(),
    )


def hostile_event_sequences(
    min_size: int = 3, max_size: int = 12
) -> st.SearchStrategy[List[Dict[str, Any]]]:
    """Build a Hypothesis strategy or event payload.

    Args:
        min_size: Input value for this helper.
        max_size: Input value for this helper.

    Returns:
        Strategy or event payload generated by this helper.

    Resources:
        None.

    Raises:
        None.
    """
    return st.lists(hostile_events(), min_size=min_size, max_size=max_size)
